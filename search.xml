<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F01%2F26%2FIPC%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[IPC是Inter-Process-Communication的缩写，意思是进程间通信或者跨进程通信；说起进程间通信，我们应该首先来了解一下什么是进程。按照操作系统的描述，线程是CPU调度的最小单元，而进程一般指一个执行单元，在移动设备上指一个程序或应用；一个进程可以包含多个线程。 Android 开启多进程模式在AndroidMenifest中为。四大组件指定 android:proccess 属性，这是唯一一种常规开启多进程的方法。如下图所示:12345678//用 : 命名，当前完整进程名要加上包名，表示当前应用的私有进程&lt;activity android:name=&quot;.TestActivityOne&quot; android:process=&quot;:test1&quot;/&gt;//不以 : 为命名的进程属于全局进程，其他应用可以通过ShareUID方式和它跑在同一进程 &lt;activity android:name=&quot;.TestActivityTwo&quot; android:process=&quot;com.test.test2&quot;/&gt; 还有一种非常规的方法，就是通过JNI在native层去fork一个新进程 多进程会造成几个方面的问题： 静态成员和单例模式完全失效(不在同一内存) 线程同步机制完成失效(与1类似) SharePreferences的可靠性下降(底层是通过读/写XML来实现的) Application会多次创建 Serializable和Parcelable的区别Serializable是Java中的序列化接口,其使用起来简单但是开销很大，序列化和反序列化过程需要大量的I/O操作。而Parcelable是Android中的序列化方式，更适合Android平台，缺点是使用起来麻烦，但是效率很高，主要用在内存序列化上。 Binder直观来说，Binder是Android中的一个类，它实现了IBinder接口。从IPC角度来说，Binder是Android中的一种跨进程通信方式，Binder还可以理解为一种虚拟的物理设备，它的设备驱动是dev/binder,该通信方式在Linux中没有；从AndroidFramework角度来说，Binder是ServiceManager连接各种Manager(ActivityManager、WindowManager,等等）和相应ManagerService的桥梁；从Android应用层来说，Binder是客户端和服务端进行通信的媒介，当bindService的时候，服务端会返回一个包含了服务端业务调用的Binder对象，通过这个Binder对象，客户端就可以获取服务端提供的服务或者数据，这里的服务包括普通服务和基于AIDL的服务。 Android中的IPC方式 Bundle 文件共享 Messenger AIDL ContentProvider ScoketBundle适用于在三大组件(Activity、Service、Receiver)里通过Bundle来传输数据，可以在不同进程中。文件共享文件共享适合在对数据同步要求不高的进程中进行通信，并且要妥善处理并发读/写的问题Messenger底层实现是AIDL。一次只处理一个请求，所以可以不必考虑线程同步的问题(因为服务端不存在并发操作) Messenger的工作原理如下： AIDL从系统自动帮我们把aidl文件生成java文件来看，核心实现是生成的内部类Sub和Sub的内部代理类Proxy。当客户端和服务端都位于同一进程时，方法调用不会走快进程的transact过程，而当两者位于不同进程时，方法调用需要走transact过程，这个逻辑由Sub的内部代理类Proxy来完成。 注意点:1.首先，当客户端发起远程诮求时，由于当前线程会被挂起直至服务端进程返回数据，所以如果一个远程方法是很耗时的，那么不能在UI线程中发起此远程请求；其次，由于服务端的Binder方法运行在Binder的线程池中，所以Binder方法不管是否耗时都应该采用同步的方式去实现，因为它已经运行在一个线程中了2.如果AIDL文件中用到了自定义的Parcelable对象，那么必须新建一个和它同名的AIDL文件，并在其中声明为Parcelable类型，如下所示：java文件：AIDL文件：3.AIDL中除了基本数据类型，其他类型的参数必须标上方向：in、out或者inout，in表示输入型参数，out表示输出型参数 4.对象是不能跨进程直接传输，对象的跨进程传输本质上都是反序列化的过程 5.防止Binder意外死亡，有两种处理方法。一种是给Binder设置DeathRecipient监听，当Binder死亡时,会在binderDied()方法里收到回调。还有一种就是在onServiceDisconnected 中重新连接远程服务。区别在于onServiceDisconnected 在客户端的UI线程中被回调，而binderDied在客户端的Binder线程池中被回调。也就是，在binderDied中不能访问UI。 6.权限认证。可以在Service中的onBind里进行验证(比如加permission验证)，也可以在具体AIDL的java类中的onTransact中进行权限认证；还可以采用Uid和Pid来做验证 ContentProvider为存储和获取数据提供统一的接口。可以在不同的应用程序之间共享数据。可支持在多个应用中存储和读取数据。底层实现也是Binder。操作流程图： 注意点：1.query、update、insert、delete四个方法是存在多线程并发访问的，因此调用方法内部要做好线程同步 ScocketSocket也称为“套接字“，是网络通信中的概念，它分为流式套接字和用户数据报套接字两种，分别对应于网络的传输控制层中的TCP和UDP协议。TCP协议是面向连接的协议，提供稳定的双向通信功能，TCP连接的建立需要经过“三次握手”才能完成，为了提供稳定的数据传输功能，其本身提供了超时重传机制，因此具有很高的稳定性：而UDP是无连接的，提供不稳定的单向通信功能，当然UDP也可以实现双向通信功能，在性能上，UDP具有更好的效率，其缺点是不保证数据一定能够正确传输，尤其是在网络拥塞的情况下。 注意点：1.需要在AndroidManifest.xml中声明权限123&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt; Binder连接池随着项目越来越大，业务模块不断增多，不同模块需要对应AIDL接口，之前的是一个业务对应一个Service。但是业务模块庞大，不适合这种单一对应，会造成系统资源不断消耗，所以要采用新的工作机制。整个工作机制是这样的：每个业务模块创建自己的AIDL接口并实现此接口，这个时候不同业务模块之间是不能有耦合的，所有实现细节我们要单独开来，然后向服务端提供自己的唯一标识和其对应的Binder对象；对于服务端来说，只要一个Service就可以了，服务端提供一个queryBinder接口，这个接口能够根据业务模块的特征来返回相应的Binder对象给它们，不间的业务模块拿到所需的Binder对象后就可以进行远程方法调用了。由此可见，Binder连接池的主要作用就是将每个业务模块的Binder请求统一转发到远程Service中去执行，从而避免了重复创建Service的过程。 选用合适的IPC方式 名称 优点 缺点 适用场景 Bundle 简单易用 只能传输Bundle支持的数据类型 四大组件间的进程通信 文件共享 简单易用 不适合高并发的情况，并且无法做到进程间的即时通讯 无并发访问情况下，交换简单的数据实时性不高的情况 AIDL 功能强大,支持一对多并发通信，支持实时通讯 需要处理好线程同步 一对多通信且有Rpc需求 Messenger 功能一般，支持一对多串行通信，支持实时通讯 不能很好处理高并发情况，不支持Rpc，数据通过Message进行传输，因此只能传输Bundle支持的数据类型 低并发的一对多即时通信,无Rpc需求，或者无需返回结果的Rpc需求 ContentProvider 在数据源访问方面功能强大,支持一对多并发数据共享，可通过Call方法扩展其他操作(call在源码编译下可调用 主要提供数据源的Crud 一对多的进程间数据共享 Socket 功能强大,可以通过网络传输字节流，支持一对多并发实时通讯 实现细节有点繁琐，不支持直接的Rpc(调用远程服务的方法) 网络数据交换]]></content>
  </entry>
</search>
